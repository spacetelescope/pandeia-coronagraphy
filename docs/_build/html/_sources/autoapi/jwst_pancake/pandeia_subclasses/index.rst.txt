:py:mod:`jwst_pancake.pandeia_subclasses`
=========================================

.. py:module:: jwst_pancake.pandeia_subclasses


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   jwst_pancake.pandeia_subclasses.CoronagraphyPSFLibrary
   jwst_pancake.pandeia_subclasses.CoronagraphyConvolvedSceneCube
   jwst_pancake.pandeia_subclasses.CoronagraphyDetectorSignal
   jwst_pancake.pandeia_subclasses.SeparateTargetReferenceCoronagraphy




Attributes
~~~~~~~~~~

.. autoapisummary::

   jwst_pancake.pandeia_subclasses.default_SPECTRAL_MAX_SAMPLES
   jwst_pancake.pandeia_subclasses.PandeiaDetectorSignal
   jwst_pancake.pandeia_subclasses.cache_maxsize


.. py:data:: default_SPECTRAL_MAX_SAMPLES
   

   

.. py:data:: PandeiaDetectorSignal
   

   

.. py:data:: cache_maxsize
   :annotation: = 256

   

.. py:class:: CoronagraphyPSFLibrary(path=None, aperture='all')

   Bases: :py:obj:`pandeia.engine.psf_library.PSFLibrary`, :py:obj:`object`

   Subclass of the Pandeia PSFLibrary class, intended to allow PSFs to be generated on-the-fly
   via webbpsf rather than using cached PSFs

   .. py:attribute:: nircam_mode
      

      

   .. py:attribute:: image_mask
      

      

   .. py:attribute:: pupil_mask
      

      

   .. py:attribute:: fov_pixels
      

      

   .. py:attribute:: trim_fov_pixels
      

      

   .. py:method:: associate_offset_to_source(self, sources, instrument, aperture_name)

      Added azimuth information for use with webbpsf. Pandeia currently does not calculate 
      the PA and assumes azimuthal symmetry resulting in incorrect calculations when using 
      the bar coronagraph. 


   .. py:method:: get_pupil_throughput(self, wave, instrument, aperture_name)

      Intended for pandeia 1.2 compatibility.


   .. py:method:: get_cached_psf(wave, instrument, aperture_name, oversample=None, source_offset=(0, 0), otf_options=None, full_aperture=None)
      :staticmethod:


   .. py:method:: get_psf(self, wave, instrument, aperture_name, oversample=None, source_offset=(0, 0), otf_options=None, full_aperture=None)


   .. py:method:: get_pix_scale(self, instrument, aperture_name)

      Get PSF pixel scale for given instrument/aperture.

      OVERRIDE Pandeia so as to make sure that the pixel scale comes out correctly.


   .. py:method:: _have_psf(self, psf_name)

      Determine whether a cached PSF exists for a given combination


   .. py:method:: _get_psf(self, psf_name)

      Return a cached PSF exists for a given combination


   .. py:method:: _pupil_throughput(ins)
      :staticmethod:

      Determines pupil throughput given a webbpsf instrument object


   .. py:method:: _get_instrument(instrument, aperture_name, source_offset=None)
      :staticmethod:


   .. py:method:: parse_aperture(aperture_name)
      :staticmethod:

      Return [image mask, pupil mask, fov_pixels, trim_fov_pixels, pixelscale]


   .. py:method:: calc_psf(ins, wave, offset, oversample, pix_scale, fov_pixels, trim_fov_pixels=None)
      :staticmethod:

      Following the treatment in pandeia_data/dev/make_psf.py to handle
      off-center PSFs for use as a kernel in later convolutions.


   .. py:method:: _log(self, level, message)

      A bypass for the inability for Pandeia to do some internal python class serialization if the
      class contains a logger



.. py:class:: CoronagraphyConvolvedSceneCube(scene, instrument, **kwargs)

   Bases: :py:obj:`pandeia.engine.astro_spectrum.ConvolvedSceneCube`

   This class overrides the ConvolvedSceneCube class, and instead of using SPECTRAL_MAX_SAMPLES it
   looks for a wavelength size that should be present in the 'scene' part of the template

   background=None, psf_library=None, webapp=False, empty_scene=False

   .. py:method:: _max_samples(self)
      :property:

      This is intended to replace a constant with a function. Maybe it works?


   .. py:method:: _log(self, level, message)

      A bypass for the inability for Pandeia to do some internal python class serialization if the
      class contains a logger



.. py:class:: CoronagraphyDetectorSignal(observation, calc_config=CalculationConfig(), **kwargs)

   Bases: :py:obj:`CoronagraphyConvolvedSceneCube`

   Override the DetectorSignal to avoid odd issues with inheritance. Unfortunately this currently
   means copying the functions entirely (with changes to which class is used)

   webapp=False, order=None, empty_scene=False

   .. py:method:: spectral_detector_transform(self)

      Create engine API format dict section containing properties of wavelength coordinates
      at the detector plane.

      Returns
      -------
      t: dict (engine API compliant keys)


   .. py:method:: wcs_info(self)

      Get detector coordinate transform as a dict of WCS keyword/value pairs.

      Returns
      -------
      header: dict
          WCS header keys defining coordinate transform in the detector plane


   .. py:method:: get_wave_pix(self)

      Return the mapping of wavelengths to pixels on the detector plane


   .. py:method:: get_fp_rate(self)

      Return scene flux at the focal plane in e-/s/pixel/micron (excludes background)


   .. py:method:: get_bg_fp_rate(self)

      Calculate background in e-/s/pixel/micron at the focal plane. Also correct for any excess in predicted background
      if there are pupil losses in the PSF. (#2529)


   .. py:method:: get_bg_pix_rate(self)

      Calculate the background on the detector in e-/s/pixel


   .. py:method:: on_detector(self, rate_list)

      This will take the list of (pixel) rates and use them create a single detector frame. A single
      image will only have one rate in the list, but the IFUs will have n_slices. There may be other examples,
      such as different spectral orders for NIRISS. It is not yet clear how many different flavors there are, so
      this step may get refactored if it gets too complicated. Observing modes that only have one set of rates
      (imaging and single-slit spectroscopy, for instance) will still go through this, but the operation is trivial.


   .. py:method:: get_pix_grid(self, rate)

      Generate the coordinate grid of the detector plane


   .. py:method:: all_rates(self, flux, add_extended_background=False)

      Calculate rates in e-/s/pixel/micron or e-/s/pixel given a flux cube in mJy

      Parameters
      ----------
      flux: ConvolvedSceneCube instance
          Convolved source flux cube with flux units in mJy
      add_extended_background: bool (default=False)
          Toggle for including extended background not contained within the flux cube

      Returns
      -------
      products: dict
          Dict of products produced by rate calculation.
              'wave_pix' - Mapping of wavelength to detector pixels
              'ote' - Source rate at the telescope aperture
              'fp' - Source rate at the focal plane in e-/s/pixel/micron
              'fp_pix' - Source rate per pixel
              'fp_pix_no_ipc' - Source rate per pixel excluding effects if inter-pixel capacitance


   .. py:method:: ote_rate(self, flux)

      Calculate source rate in e-/s/pixel/micron at the telescope entrance aperture given
      a flux cube in mJy/pixel.


   .. py:method:: focal_plane_rate(self, rate)

      Takes the output from self.ote_rate() and multiplies it by the components
      of efficiency within the system and returns the source rate at the focal plane in
      e-/s/pixel/micron.


   .. py:method:: spec_rate(self, rate)

      For slitted spectrographs, calculate the detector signal by integrating
      along the dispersion direction of the cube (which is masked by a, by assumption,
      narrow slit). For slitless systems or slits wider than the PSF, the slitless_rate
      method should be used to preserve spatial information within the slit.

      Parameters
      ---------
      rate: numpy.ndarray
          Rate of photons interacting with detector as a function of model wavelength set

      Returns
      -------
      products: 3-element tuple of numpy.ndarrays
          first element - map of pixel to wavelength
          second element - electron rate per pixel
          third element - variance of electron rate per pixel


   .. py:method:: image_rate(self, rate)

      Calculate the electron rate for imaging modes by integrating along
      the wavelength direction of the cube.

      Parameters
      ---------
      rate: numpy.ndarray
          Rate of photons interacting with detector as a function of model wavelength set

      Returns
      -------
      products: 2-element tuple of numpy.ndarrays
          first element - electron rate per pixel
          second element - variance of electron rate per pixel


   .. py:method:: slitless_rate(self, rate, add_extended_background=True)

      Calculate the detector rates for slitless modes. Here we retain all spatial information and build
      up the detector plane by shifting and coadding the frames from the convolved flux cube. Also need to handle
      and add background that comes from outside the flux cube, but needs to be accounted for.

      Parameters
      ----------
      rate: 3D numpy.ndarray
          Cube containing the flux rate at the focal plane
      add_extended_background: bool (default: True)
          Toggle for including extended background not contained within the flux cube

      Returns
      -------
      products: 2 entry tuple
          wave_pix: 1D numpy.ndarray containing wavelength to pixel mapping on the detector plane
          spec_rate: 2D numpy.ndarray of detector count rates


   .. py:method:: wave_eff(self, rate)


   .. py:method:: get_projection_type(self)


   .. py:method:: ipc_convolve(self, rate, kernel)


   .. py:method:: get_saturation_mask(self, rate=None)

      Compute a numpy array indicating pixels with full saturation (2), partial saturation (1) and no saturation (0).

      Parameters
      ----------
      rate: None or 2D np.ndarray
          Detector plane rate image used to build saturation map from

      Returns
      -------
      mask: 2D np.ndarray
          Saturation mask image


   .. py:method:: _groups_before_sat(self, slope, fullwell)

      Fix for Pandeia 1.2/1.3, since exposure spec doesn't have this in 1.2



.. py:class:: SeparateTargetReferenceCoronagraphy

   Bases: :py:obj:`pandeia.engine.strategy.Coronagraphy`

   This class is intended to override the cronography behaviour of requiring that the reference 
   source be included in the same calculation template as the observation source.

   .. py:method:: _create_weight_matrix(self, my_detector_signal_list, my_detector_noise_list)

      This private method creates the weight matrix, a_ij, used for the strategy sum. It gets overridden
      in each strategy. In this case, it applies all weight to the first (and only) target. As such, it
      deliberately uses the weight matrix creation from the ImagingApPhot class



